"use strict";
/**
 * This is the second version of my caustic shader.
 * It is split into parts with the code for main function(s) and parts
 * with the uniforms/varying definitions.
 *
 * This makes it easy to combine it with existing shaders from THREEJS
 * by using the onCompile method with text replacement.
 *
 * @author  Ikaros Kappler
 * @date    2023-05-03
 * @version 1.0.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Caustic_Shader2 = void 0;
var vertex_pars = /* glsl */ "\n        // varying vec2 vUv; \n        varying vec3 vposition;\n";
var vertex = /* glsl */ "\n        // varying vec2 vUv; \n        // varying vec3 vposition;\n\n        // void main() {\n            // This is just the local position.\n            vUv = uv; // position;\n            // This is the global position in the world.\n            vposition = (modelMatrix * vec4(position, 1.0)).xyz;\n\n            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);\n            gl_Position = projectionMatrix * modelViewPosition; \n        // }\n";
var fragment_pars = /* glsl */ "\n\n        // #define FOG_EXP2 1\n\n        // Scales the effect\n        uniform float u_zoom;\n        // The effect speed\n        uniform float u_speed;\n        // General brightness\n        uniform float u_bright;\n        // Intensity, like the maximal alpha value of the effect\n        uniform float u_intensity;\n        // The current shader animation time frame\n        uniform float u_time;\n        // The underlying texture to use\n        uniform sampler2D u_texture;\n        // The effect color on its peak brightness value\n        uniform vec4 u_effect_color;\n\n        // ### USE FOG \n        // uniform vec3 fogColor;\n        // varying float vFogDepth;\n        // #ifdef FOG_EXP2\n        //    uniform float fogDensity;\n        // #else\n        //    uniform float fogNear;\n        //    uniform float fogFar;\n        // #endif\n\n        // varying vec2 vUv;\n        varying vec3 vposition;\n\n        // Source for Hue/Brightness/Saturation in GLSL\n        //    https://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\n        //    http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n        vec3 rgb2hsv(vec3 c)\n        {\n            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n            float d = q.x - min(q.w, q.y);\n            float e = 1.0e-10;\n            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n        }\n\n        vec3 hsv2rgb(vec3 c)\n        {\n            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n        }\n";
var fragment = /* glsl */ "\n\n        // #define FOG_EXP2 1\n\n        // Scales the effect\n        // uniform float u_zoom;\n        // The effect speed\n        // uniform float u_speed;\n        // General brightness\n        // uniform float u_bright;\n        // Intensity, like the maximal alpha value of the effect\n        // uniform float u_intensity;\n        // The current shader animation time frame\n        // uniform float u_time;\n        // The underlying texture to use\n        // uniform sampler2D u_texture;\n        // The effect color on its peak brightness value\n        // uniform vec4 u_effect_color;\n\n        // ### USE FOG \n        // uniform vec3 fogColor;\n        // varying float vFogDepth;\n        // #ifdef FOG_EXP2\n        //    uniform float fogDensity;\n        // #else\n        //     uniform float fogNear;\n        //    uniform float fogFar;\n        // #endif\n\n        // varying vec2 vUv;\n        // varying vec3 vposition;\n\n\n        // void main() {\n\n             // uncoment when using real texture\n            // vec4 texture_color = texture2D(u_texture, vUv.xy);\n            // Re-use fragment color from shader pipeline\n            vec4 texture_color = gl_FragColor;\n            vec4 k = vec4(u_time)*u_speed;\n            // Use the xz-coordinated to view from top\n            k.xy = vec2(vposition.x, vposition.z) * u_zoom;\n            vec3 factors = vec3(1.0,1.0,1.0);\n            float val1 = length(0.5-fract(k.xyw*=mat3(vec3(-2.0,-1.0,0.0), vec3(3.0,-1.0,1.0), vec3(1.0,-1.0,-1.0))*factors.x*0.5));\n            float val2 = length(0.5-fract(k.xyw*=mat3(vec3(-2.0,-1.0,0.0), vec3(3.0,-1.0,1.0), vec3(1.0,-1.0,-1.0))*factors.y*0.2));\n            float val3 = length(0.5-fract(k.xyw*=mat3(vec3(-2.0,-1.0,0.0), vec3(3.0,-1.0,1.0), vec3(1.0,-1.0,-1.0))*factors.z*0.5));\n            gl_FragColor = vec4 (pow(min(min(val1,val2),val3), 8.0) * u_bright)+texture_color;\n            float brightValue = pow(min(min(val1,val2),val3), 8.0) * u_bright;\n            // gl_FragColor = texture_color + (u_effect_color-texture_color) * min(u_intensity,brightValue);\n\n            // vec3 vHSV = vec3(1,1,1);\n            // vec3 fragRGB = texture_color.rgb;\n            // vec3 fragHSV = rgb2hsv(fragRGB).xyz;\n            // fragHSV.x += vHSV.x / 360.0;\n            // fragHSV.yz *= vHSV.yz;\n            // fragHSV.xyz = mod(fragHSV.xyz, 1.0);\n            // fragRGB = hsv2rgb(fragHSV);\n            // gl_FragColor = vec4(fragRGB, texture_color.w);\n\n            // vec3 vHSV = vec3(1.0,1.0,1.0);\n            // TODO: convert this to a VARYING\n            vec3 vHSV = rgb2hsv(u_effect_color.rgb).rgb;\n            vec3 fragRGB = texture_color.rgb;\n            // vec3 fragRGB = mix( texture_color.rgb, u_effect_color.rgb, u_bright*0.25 );\n            // vec3 fragRGB = (texture_color + (u_effect_color-texture_color) * min(u_intensity,brightValue)).rgb;\n            vec3 fragHSV = rgb2hsv(fragRGB).xyz;\n            // fragHSV.x += mod(min(u_intensity,brightValue), 360.0);\n            fragHSV.z += mod( min(u_intensity,brightValue), 1.0);\n            // fragHSV.x += vHSV.x / 360.0;\n            // fragHSV.yz *= vHSV.yz;\n            fragHSV.xyz = mod(fragHSV.xyz, 1.0);\n            fragRGB = hsv2rgb(fragHSV);\n            gl_FragColor = vec4(fragRGB, texture_color.w);\n            \n            // gl_FragColor.rgb = mix( gl_FragColor.rgb, u_effect_color.rgb, brightValue*u_intensity*0.25 );\n            // Try to mix in the effect color.\n            gl_FragColor.rgb += (u_effect_color.rgb * (1.0- brightValue*u_intensity)) * 0.15;\n\n            // -- <fog_fragment>\n            // Note: fogFactor is here taken from the underlying shader. No need to re-define it here\n            // float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n            gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n        // }\n";
exports.Caustic_Shader2 = {
    fragment: fragment,
    fragment_pars: fragment_pars,
    vertex: vertex,
    vertex_pars: vertex_pars
};
//# sourceMappingURL=caustic_shader_material2.glsl.js.map